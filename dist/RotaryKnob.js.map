{"mappings":"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","sources":["./node_modules/@parcel/scope-hoisting/lib/helpers.js","./src/RotaryKnob.tsx"],"sourcesContent":["var $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$export(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n","import React, { useEffect, useRef, useState } from \"react\";\n\nexport default RotaryKnob;\nfunction RotaryKnob({\n  width = 160,\n  height = 160,\n  value = 80,\n  max = 127,\n  backgroundColor = \"#ccc\",\n  color = \"#37332ee0\",\n}) {\n  const caretWidth = width / 40;\n  const canvasRef: any = useRef(null);\n  const context = useRef(null);\n  const [val, setVal] = useState(value);\n  const isDragging = useRef(false);\n  const verticalDiff = useRef(0);\n  const lastOffset = useRef(0);\n\n  useEffect(() => {\n    const canvas: any = canvasRef.current;\n\n    context.current = canvas.getContext(\"2d\");\n    const ctx: any = context.current;\n    var radius = canvas.height / 2;\n    lastOffset.current = valToY(val);\n    ctx.translate(radius, radius);\n    drawGrad(ctx);\n    draw(valToY(val));\n  }, []);\n\n  return (\n    <div>\n      <canvas\n        width={width}\n        height={height}\n        onPointerDown={handleDown}\n        onPointerMove={handleMove}\n        onPointerUp={handleCancel}\n        ref={canvasRef}\n      />\n      <div>{val.toString().slice(0, 5)}</div>\n    </div>\n  );\n\n  function yToVal(y: number) {\n    const tH = canvasRef.current.height;\n    const val = y / tH;\n    const ttH = 1;\n    const tmpVal = val < 0 ? 0 : val > ttH ? ttH : val;\n    const ttval = isNaN(tmpVal) ? value : tmpVal;\n    return ttval;\n  }\n\n  function valToY(val: number) {\n    const tmpVal = canvasRef.current.height * val / max;\n    return tmpVal;\n  }\n\n  function drawGrad(ctx: any) {\n    ctx.beginPath();\n    const tmpGrad = ctx.createLinearGradient(0, 0, 0, 170);\n    tmpGrad.addColorStop(0, backgroundColor);\n    tmpGrad.addColorStop(1, color);\n    ctx.fillStyle = tmpGrad;\n    ctx.fillRect(20, 20, 150, 100);\n    ctx.fill();\n    ctx.closePath();\n  }\n  function draw(vDiff: number) {\n    const ctx: any = context.current;\n    if (!ctx.canvas) return;\n    const val = yToVal(vDiff);\n    setVal(val * max);\n    drawCaret(ctx, -val * Math.PI * 2);\n  }\n\n  function handleDown(ev: any) {\n    canvasRef.current.setPointerCapture(ev.pointerId);\n    verticalDiff.current = ev.nativeEvent.offsetY;\n    isDragging.current = true;\n  }\n\n  function handleMove(e: any) {\n    if (isDragging.current === true) {\n      const tV = -e.nativeEvent.offsetY + verticalDiff.current +\n        lastOffset.current;\n      draw(tV);\n    }\n  }\n\n  function handleCancel(ev: any) {\n    canvasRef.current.releasePointerCapture(ev.pointerId);\n    lastOffset.current = valToY(val);\n    isDragging.current = false;\n  }\n\n  function drawCaret(ctx: any, pos: number) {\n    ctx.clearRect(\n      -canvasRef.current.width / 2,\n      -canvasRef.current.height / 2,\n      width,\n      height,\n    );\n    ctx.lineWidth = caretWidth;\n    ctx.beginPath();\n    ctx.arc(\n      0,\n      0,\n      canvasRef.current.width / 2 - 2 * caretWidth,\n      0,\n      Math.PI * 2,\n      true,\n    );\n    ctx.closePath();\n    ctx.fill();\n\n    ctx.lineWidth = caretWidth;\n    ctx.lineCap = \"round\";\n    ctx.strokeStyle = color;\n    ctx.moveTo(0, 0);\n    ctx.rotate(-pos);\n    ctx.lineTo(0, -canvasRef.current.width / 2 + 2 * caretWidth);\n    ctx.stroke();\n    ctx.rotate(pos);\n    // ctx.font = \"30px Arial\";\n    //ctx.strokeText(val, -2*caretWidth, caretWidth);\n  }\n}\n"],"names":["a","__esModule","default","_ref","width","_ref$width","_ref$height","height","_ref$value","value","_ref$max","max","_ref$backgroundColor","backgroundColor","_ref$color","color","caretWidth","canvasRef","useRef","context","useState","val","setVal","isDragging","verticalDiff","lastOffset","useEffect","canvas","current","getContext","ctx","radius","valToY","translate","beginPath","tmpGrad","createLinearGradient","addColorStop","fillStyle","fillRect","fill","closePath","drawGrad","draw","onPointerDown","ev","setPointerCapture","pointerId","nativeEvent","offsetY","onPointerMove","e","onPointerUp","releasePointerCapture","ref","toString","slice","vDiff","y","tmpVal","isNaN","yToVal","pos","clearRect","lineWidth","arc","Math","PI","lineCap","strokeStyle","moveTo","rotate","lineTo","stroke","drawCaret"],"version":3,"file":"RotaryKnob.js.map"}